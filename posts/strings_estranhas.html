<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-br" xml:lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Gabriel Dertoni" />
  <meta name="dcterms.date" content="2021-05-26" />
  <meta name="keywords" content="C, string" />
  <title>Strings s√£o estranhas</title>
  <style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
}
pre.numberSource { margin-left: 3em; padding-left: 4px; }
div.sourceCode
{ color: #ebdbb2; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #ebdbb2; } 
code span.al { color: #282828; background-color: #cc241d; font-weight: bold; } 
code span.an { color: #98971a; } 
code span.at { color: #d79921; } 
code span.bn { color: #f67400; } 
code span.bu { color: #d65d0e; } 
code span.cf { color: #cc241d; font-weight: bold; } 
code span.ch { color: #b16286; } 
code span.cn { color: #b16286; font-weight: bold; } 
code span.co { color: #928374; } 
code span.cv { color: #928374; } 
code span.do { color: #98971a; } 
code span.dt { color: #d79921; } 
code span.dv { color: #f67400; } 
code span.er { color: #cc241d; text-decoration: underline; } 
code span.ex { color: #689d6a; font-weight: bold; } 
code span.fl { color: #f67400; } 
code span.fu { color: #689d6a; } 
code span.im { color: #689d6a; } 
code span.in { color: #282828; background-color: #83a598; } 
code span.kw { color: #ebdbb2; font-weight: bold; } 
code span.op { color: #ebdbb2; } 
code span.ot { color: #689d6a; } 
code span.pp { color: #d65d0e; } 
code span.re { color: #928374; background-color: #1d2021; } 
code span.sc { color: #b16286; } 
code span.ss { color: #98971a; } 
code span.st { color: #98971a; } 
code span.va { color: #458588; } 
code span.vs { color: #848216; } 
code span.wa { color: #282828; background-color: #fabd2f; } 
</style>
  <style type="text/css">@import url('https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter&display=swap')</style>
  <style type="text/css">:root {
--bg: #282828;
--bg0-h: #1d2021;
--bg0-s: #32302f;
--bg0: #282828;
--bg1: #3c3836;
--bg2: #504945;
--bg3: #665c54;
--bg4: #7c6f64;
--fg: #ebdbb2;
--fg0: #fbf1c7;
--fg1: #ebdbb2;
--fg2: #d5c4a1;
--fg3: #bdae93;
--fg4: #a89984;
--dark-red: #cc241d;
--dark-green: #98971a;
--dark-yellow: #d79921;
--dark-orange: #d65d0e;
--dark-blue: #458588;
--dark-purple: #b16286;
--dark-aqua: #689d6a;
--dark-grey: #a89984;
--light-red: #fb4934;
--light-green: #b8bb26;
--light-yellow: #fabd2f;
--light-orange: #fe8019;
--light-blue: #83a598;
--light-purple: #d3869b;
--light-aqua: #8ec07c;
--light-grey: #928374;
--top-bar-bg-color: var(--fg0);
--top-bar-fg-color: var(--bg0-h);
--nav-bar-link-color: var(--fg0);
--nav-bar-link-hover-color: var(--light-orange);
--main-text-color: var(--fg);
--title-color: var(--light-aqua);
--section-color: var(--light-blue);
--link-color: var(--dark-blue);
--link-hover-color: var(--light-blue);
--inline-code-color: var(--light-orange);
--inline-code-bg-color: var(--bg1);
--code-bg-color: var(--bg1);
--content-width: 800px;
--keywords-color: var(--fg4);
--article-list-bg-color: var(--bg1);
--article-list-fg-color: var(--light-aqua);
--author-color: var(--dark-aqua);
}
::-webkit-scrollbar-thumb {
border-radius: 10px;

background-color: #0f0f0f;
}
::-webkit-scrollbar {
width: 12px;
height: 12px;
background-color: #282828;
}
::-webkit-scrollbar-track {
-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
border-radius: 10px;
background-color: #282828;
}
body {
padding: 2em;
font-size: 1rem;
padding-top: 0;
background-color: #282828;
color: var(--main-text-color);
font-family: 'Fira Code', monospace;
font-variant-ligatures: normal;
display: flex;
flex-flow: column nowrap;
align-items: center;
}
header {
width: 100%;
display: flex;
flex-flow: column nowrap;
align-items: center;
}
a {
color: var(--link-color);
transition: color ease-in 100ms;
font-weight: 600;
}
a:hover {
color: var(--link-hover-color);
}
h1 {
color: var(--title-color);
}
h1.title {
margin-bottom: .3em;
}
h1::after {
content: '';
display: block;
width: 100%;
border-bottom: solid 3px;
}
h2 {
color: var(--section-color);
}
code {
padding: 1px 6px;
border-radius: 3px;
color: var(--inline-code-color);
background-color: var(--inline-code-bg-color);
font-family: 'Fira Code';
font-variant-ligatures: normal;
}
code:not(.sourceCode) {
font-size: .8em;
}
pre code {
padding: 0;
border-radius: 0;
color: var(--main-text-color);
background-color: transparent;
font-size: 1em;
font-weight: normal;
}
pre.sourceCode {
padding: 1em;
background-color: var(--code-bg-color);
border-radius: 5px;
overflow: auto;
font-size: .9em;
}
p {
text-align: justify;
}
.text-underline {
text-decoration: underline;
}
.text-ligatures {
font-variant-ligatures: normal;
}
.text-hide {
display: none;
}
.list-title {
margin-bottom: 0;
}
.list-title ~ ul {
margin-top: 0;
}
.width-content {
width: var(--content-width);
}
.no-bottom-margin {
margin-bottom: 0;
}
#top-bar {
width: 100%;
padding: .5em;
background-color: var(--top-bar-bg-color);
color: var(--top-bar-fg-color);
display: flex;
flex-flow: row nowrap;
justify-content: center;
}
.blog-title {
text-transform: uppercase;
font-weight: bold;
}
#menu ul {
padding: 0;
display: flex;
flex-flow: row nowrap;
justify-content: flex-start;
gap: 2rem;
}
#menu ul li {
list-style: none;
}
#menu ul li a {
color: var(--nav-bar-link-color);
transition: color ease-in 100ms;
}
#menu ul li a:hover {
color: var(--nav-bar-link-hover-color);
}
.keywords > ul {
margin-top: 0;
display: flex;
flex-flow: row nowrap;
gap: 1em;
padding: 0;
color: var(--keywords-color);
}
.keywords > ul > li {
list-style: none;
}
.article-list > ul {
display: flex;
flex-flow: column nowrap;
gap: 1em;
padding: 0;
}
.article-list > ul > li {
padding: 0 1em;
background-color: var(--article-list-bg-color);
list-style: none;
}
.article-list > ul > li a {
font-variant-ligatures: normal;
color: var(--article-list-fg-color);
}
.article-title {
color: var(--title-color);
}
.article-title::after {
content: '';
display: block;
width: 100%;
border-bottom: solid 3px;
}
.author {
color: var(--author-color);
margin-top: .3em;
}
@media screen and (max-width: 1000px) {
.width-content {
width: calc(100% - 1rem);
}
body {
padding: 0;
font-size: .8rem;
}
}
</style>
</head>
    <body>
        <header>
            <div id="top-bar">
                <div class="width-content">
                    <div class="blog-title">Gabriel Dertoni</div>
                </div>
            </div>
            <nav class="width-content" id="menu">
                <ul>
                    <li><a href="/index.html">Index</a></li>
                    <li><a href="/about.html">About</a></li>
                </ul>
            </nav>
        </header>        <main class="width-content">
            <div id="title-block-header">
                <h1 class="title">Strings s√£o estranhas</h1>
                <div class="keywords">
                    <ul>
                                                <li>#C</li>
                                                <li>#string</li>
                                            </ul>
                </div>
                <div class="authors">
                    <!-- Puts "Escrito por" when `lang-pt` is set and "Authored by" when `lang-en` is set -->
                    <p class="author"> Gabriel Dertoni @ May 26, 2021</p>
                </div>
            </div>
            <nav id="TOC">
                <!-- Puts "Conte√∫do" when `lang-pt` is set and "Contents" when `lang-en` is set -->
                <p class="list-title text-underline">Conte√∫do:</p>
                <ul>
                <li><a href="#introdu√ß√£o" id="toc-introdu√ß√£o">Introdu√ß√£o</a></li>
                <li><a href="#strings-em-c" id="toc-strings-em-c">Strings em C</a></li>
                <li><a href="#strings-est√°ticas" id="toc-strings-est√°ticas">Strings est√°ticas</a></li>
                <li><a href="#strings-alocadas-na-stack" id="toc-strings-alocadas-na-stack">Strings alocadas na stack</a></li>
                <li><a href="#strings-na-heap" id="toc-strings-na-heap">Strings na heap</a></li>
                <li><a href="#unicode-e-ascii" id="toc-unicode-e-ascii">Unicode e ASCII</a></li>
                </ul>
            </nav>
            <h2 id="introdu√ß√£o">Introdu√ß√£o</h2>
            <p>Quando estamos come√ßando a programar, frequentemente encontramos as famosas ‚Äústrings‚Äù. Elas s√£o conjuntos de caracteres, palavras, frases, qualquer coisa que se possa pensar como texto. Parece simples certo? Bem sim, o conceito em si √© simples, entretanto existem alguns detalhes na hora de usar elas em programa que podem n√£o ser imediatamente √≥bvios.</p>
            <h2 id="strings-em-c">Strings em C</h2>
            <p>Na linguagem C especialmente, todas as strings s√£o terminadas por um caractere <code>&#39;\0&#39;</code>. Esse delimitador serve para justamente indicar o fim de uma sequ√™ncia de caracteres. √â uma forma de dizer ‚Äúse voc√™ ler daqui pra frente, √© poss√≠vel que d√™ merda‚Äù. Esse valor especial, o <code>&#39;\0&#39;</code> √© simplesmente o byte de valor 0. De maneira geral h√° a vantagem de que podemos passar strings pra c√° e pra l√° apenas como ponteiros para o primeiro caractere da cadeia, j√° que sabemos que podemos ler a vontade at√© o <code>&#39;\0&#39;</code>. Na pr√°tica, isso facilita, j√° que n√£o precisamos o tempo todo dizer explicitamente quantos caracteres a string t√™m.</p>
            <p>Ou seja, sempre que queremos representar uma string em C, pegamos o endere√ßo ao primeiro caractere da sequ√™ncia e isso basta, a partir dele sabemos pegar o pr√≥ximo e o seguinte e assim por diante at√© o <code>&#39;\0&#39;</code>.</p>
            <p>Ent√£o, de maneira mais espec√≠fica, <code>char *</code> representa um ponteiro (vari√°vel que armazena endere√ßo de mem√≥ria) que aponta para algum lugar qualquer da mem√≥ria. Esse lugar pode ser heap, stack ou para qualquer outra regi√£o da mem√≥ria. O valor no endere√ßo de mem√≥ria apontado pelo <code>char *</code> ser√° algum caractere ou um <code>&#39;\0&#39;</code>. Se for um caractere normal, sabemos que o endere√ßo de mem√≥ria seguinte, tamb√©m √© parte da string. No endere√ßo seguinte podemos verificar novamente se √© <code>&#39;\0&#39;</code> e se for, sabemos ter encontrado o endere√ßo do fim da string.</p>
            <h2 id="strings-est√°ticas">Strings est√°ticas</h2>
            <p>Nem todas as strings nascem iguais, algumas s√£o fornecidas pelo usu√°rio, algumas lida de arquivos e algumas s√£o forjadas dentro do bin√°rio do programa. Essas √∫ltimas s√£o as strings est√°ticas. Na hora de executar seu c√≥digo, l√° est√£o elas, dentro do bin√°rio em si. √â poss√≠vel v√™-las ao tentar abrir o bin√°rio do seu programa num editor de texto qualquer. A maior parte ser√° um monte de lixo, mas ao procurar bem, l√° estar√£o elas. Alternativamente o utilit√°rio do Linux <code>strings</code> imprime todos os caracteres imprim√≠veis na tela contidos em qualquer bin√°rio.</p>
            <p>Ent√£o, como criamos elas? Bem, voc√™ provavelmente j√° as viu ou usou! Elas s√£o criadas toda vez que escrevemos algo entre aspas duplas. Ou seja, quando seu programa faz <code>printf(&quot;Hello, world!&quot;)</code>, esse <code>Hello, world!</code> estar√° forjado nas entranhas bin√°rias do seu execut√°vel!</p>
            <p>Toda vez que voc√™ roda seu programa, o sistema operacional joga todo o bin√°rio do programa para a mem√≥ria RAM. Junto com as instru√ß√µes em linguagem de m√°quina, se encontra seu <code>Hello, world!</code>. A vari√°vel que voc√™ usa em C, na verdade √© apenas um ponteiro que aponta para o local na mem√≥ria onde a sua string foi posta. Um <code>char *</code> define uma vari√°vel que armazena um n√∫mero. Esse n√∫mero representa um endere√ßo na mem√≥ria. Nesse endere√ßo se encontra o primeiro caractere da sua string.</p>
            <p>Isso √© muito importante! Strings est√°ticas est√£o efetivamente junto com o resto do seu execut√°vel, elas n√£o se encontram na stack ou muito menos heap. Entretanto, essa regi√£o de mem√≥ria onde o c√≥digo fica n√£o t√™m permiss√£o de escrita, ou seja, strings est√°ticas <strong>n√£o podem ser modificadas</strong> e por isso ganham esse nome. Ao tentar modificar uma string est√°tica, seremos recebidos pelo infame <code>Segfault</code>.</p>
            <div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ser√° armazenada no bin√°rio do programa.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>minha_string_estatica <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> minha_string_estatica<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//     ^^^^ olha outra string est√°tica aqui!</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    minha_srting_estatica<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;h&#39;</span><span class="op">;</span> <span class="co">// Segfault!</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Apesar de C ser uma linguagem que tende a te dar total liberdade, nesse caso, se quisermos que o compilador verifique para n√≥s que n√£o estamos sem querer tentando modificar uma string est√°tica, podemos usar a palavra <code>const</code> ao declarar uma vari√°vel. Ao fazermos isso, o compilador nos avisar√° toda vez que tentarmos modificar essa vari√°vel e n√£o teremos o terr√≠vel <code>Segfault</code>.</p>
            <div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>minha_string_estatica <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>minha_srting_estatica<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;h&#39;</span><span class="op">;</span> <span class="co">// Erro de compila√ß√£o.</span></span></code></pre></div>
            <p>Al√©m disso algumas fun√ß√µes podem receber um argumento <code>const char *</code> o que significa que a fun√ß√£o promete n√£o tentar alterar o conte√∫do naquela localiza√ß√£o de mem√≥ria. Repare que o primeiro argumento do <code>printf</code> √© <code>const</code>, ou seja, tudo bem utilizarmos strings est√°ticas como primeiro argumento para essa fun√ß√£o.</p>
            <p>Por conta disso, quando estiver trabalhando com strings est√°ticas, <strong>sempre use <code>const</code></strong>.</p>
            <h2 id="strings-alocadas-na-stack">Strings alocadas na stack</h2>
            <p>Assim como qualquer vari√°vel na stack, strings na stack tamb√©m n√£o podem crescer de tamanho e <strong>possuem seu tamanho determinado em tempo de compila√ß√£o</strong>. Nesse aspecto, a linguagem C d√° uma m√£ozinha com sintaxe como veremos.</p>
            <p>Para criar uma string na stack, usamos a mesma nota√ß√£o de <em>array</em>, afinal strings s√£o apenas <em>arrays</em> de caracteres.</p>
            <div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> nome<span class="op">[</span><span class="dv">20</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;josimar&quot;</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;nome: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> nome<span class="op">);</span></span></code></pre></div>
            <p>Olha s√≥, ainda usamos as mesmas aspas da string est√°tica e de fato, o lado direito do <code>=</code> √© realmente uma string est√°tica! Mas algo mudou, ao fazermos</p>
            <div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> nome<span class="op">[</span><span class="dv">20</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;josimar&quot;</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>nome<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;J&#39;</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;nome: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> nome<span class="op">);</span></span></code></pre></div>
            <p>N√£o ocorre qualquer problema! Bem isso √© porque o compilador est√° escondendo alguns detalhes. Na realidade, ele cria a string est√°tica <code>&quot;josimar&quot;</code> e separa 20 bytes para a vari√°vel <code>nome</code> na stack. Depois disso, ele coloca uma instru√ß√£o que copia a string est√°tica para dentro da vari√°vel na stack. Na realidade, esse c√≥digo poderia ser reescrito da seguinte maneira</p>
            <div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> nome<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>nome<span class="op">,</span> <span class="st">&quot;josimar&quot;</span><span class="op">);</span></span></code></pre></div>
            <p>Aqui fica mais claro o que est√° realmente acontecendo. A opera√ß√£o <code>strcpy</code> s√≥ acontece em tempo de execu√ß√£o, quando a stack j√° existe, e ela s√≥ copia os conte√∫dos da string est√°tica. Assim, podemos modificar livremente a vari√°vel <code>nome</code>.</p>
            <p>Entretanto, ainda temos que dizer explicitamente que essa string pode ter <strong>no m√°ximo</strong> 20 caracteres. Mas e se quisermos mudar o c√≥digo? Teremos que ficar contando os caracteres? E tem que lembrar do espa√ßo pro <code>&#39;\0&#39;</code> no final! Bem, existe uma sa√≠da. O compilador sabe contar o tamanho de strings est√°ticas, ent√£o podemos s√≥ escrever</p>
            <div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> nome<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;josimar&quot;</span><span class="op">;</span></span></code></pre></div>
            <p>E tudo se d√° por resolvido.</p>
            <p>Al√©m disso, repare que podemos usar <code>char nome[]</code> no lugar de qualquer ponteiro <code>char *</code>. Isso porque, na realidade, <code>char nome[]</code> √© um ponteiro tamb√©m, ele s√≥ est√° escondido com uma cara diferente. Essa diferen√ßa s√≥ existe em tempo de compila√ß√£o.</p>
            <p>Al√©m disso, quando estamos usando strings na stack atrav√©s de arrays de caracteres, podemos tratar elas como tratamos qualquer vetor! Ou seja, se quisermos calcular o tamanho da string, podemos fazer isso em tempo de compila√ß√£o utilizando o <code>sizeof</code>. Considerando o exemplo anterior com a vari√°vel <code>nome</code>, podemos fazer</p>
            <div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aqui precisamos do -1 no final se n√£o quisermos contar o &#39;\0&#39;.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tamanho_nome <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>nome<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
            <p>Essa opera√ß√£o √© inteiramente calculada em tempo de compila√ß√£o, ent√£o nenhum precioso ciclo de clock ser√° gasto iterando na string at√© encontrar o <code>&#39;\0&#39;</code>!</p>
            <h2 id="strings-na-heap">Strings na heap</h2>
            <p>Por fim, chegamos na heap, o lugar mais flex√≠vel de todos. Aqui as strings n√£o s√≥ podem ser alteradas como tamb√©m podem crescer e diminuir de tamanho. A parte chata √© que temos que sempre trabalhar com um par de fun√ß√µes em especial: <code>malloc</code> e <code>free</code>.</p>
            <p>Al√©m disso, o compilador n√£o tem tantas boas surpresas como tinha no caso da stack. Temos que manualmente usar <code>strcpy</code> ou ler de algum lugar.</p>
            <div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>nome <span class="op">=</span> <span class="st">&quot;Josh&quot;</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>sobrenome <span class="op">=</span> <span class="st">&quot;Johnson&quot;</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Aloca espa√ßo na heap para a string. N√£o esque√ßa do +1 para o &#39;\0&#39;.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>heap_str <span class="op">=</span> <span class="op">(</span><span class="dt">char</span> <span class="op">*)</span>malloc<span class="op">((</span>strlen<span class="op">(</span>nome<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">));</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>heap_str<span class="op">,</span> nome<span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;nome: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> heap_str<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">// +1 para um espa√ßo entre nome e sobrenome.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> novo_tamanho <span class="op">=</span> strlen<span class="op">(</span>nome<span class="op">)</span> <span class="op">+</span> strlen<span class="op">(</span>sobrenome<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Aumenta o tamanho alocado. +1 para o &#39;\0&#39;.</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>heap_str <span class="op">=</span> <span class="op">(</span><span class="dt">char</span> <span class="op">*)</span>realloc<span class="op">(</span>heap_str<span class="op">,</span> <span class="op">(</span>novo_tamanho <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">));</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Adiciona um espa√ßo depois do nome.</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>heap_str<span class="op">[</span>strlen<span class="op">(</span>nome<span class="op">)]</span> <span class="op">=</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Copia o sobrenome para depois do nome e espa√ßo.</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>heap_str <span class="op">+</span> strlen<span class="op">(</span>nome<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> sobrenome<span class="op">);</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;nome completo: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> heap_str<span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Libera o espa√ßo alocado na heap.</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>free<span class="op">(</span>heap_str<span class="op">);</span></span></code></pre></div>
            <h2 id="unicode-e-ascii">Unicode e ASCII</h2>
            <p>Por padr√£o, o tipo <code>char</code>, da linguagem C possui apenas 1 byte em tamanho. Isso significa que apenas caracteres ASCII podem caber em uma vari√°vel dessas. Ou seja, letras com acento ou s√≠mbolos como <code>√ß</code> n√£o podem ser atribu√≠dos a essas vari√°veis.</p>
            <p>Entretanto, existe um jeito. Na realidade, caracteres com acento ocupam 2 bytes ou mais, mas √© s√≥ isso que elas s√£o. Isso significa que dentro de uma string podemos sim usar acento, mas metade dos dados do caractere ficar√£o armazenados em um endere√ßo e a outra metade noutro. Isso dificulta alguns tipos de processamento, por exemplo quando queremos comparar alfabeticamente duas strings. Entretanto, sabendo disso, √© sim poss√≠vel utilizar acentos e caracteres especiais (incluindo emojis) em strings de C. Quando a string for impressa no terminal, os bytes que comp√µe o caractere especial ser√£o s√≥ impressos em sequ√™ncia, e o terminal ser√° capaz de detectar isso e interpretar como um lindo emoji, ou qualquer coisa do g√™nero.</p>
            <div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>happy <span class="op">=</span> <span class="st">&quot;üòä&quot;</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> happy<span class="op">);</span> <span class="co">// Funciona sem problemas.</span></span></code></pre></div>
        </main>
    </body>
</html>
