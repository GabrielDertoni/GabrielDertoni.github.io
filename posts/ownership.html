<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-br" xml:lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Gabriel Dertoni" />
  <title>Como nunca sofrer de segfault e double free</title>
  <style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
}
pre.numberSource { margin-left: 3em; padding-left: 4px; }
div.sourceCode
{ color: #ebdbb2; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #ebdbb2; } 
code span.al { color: #282828; background-color: #cc241d; font-weight: bold; } 
code span.an { color: #98971a; } 
code span.at { color: #d79921; } 
code span.bn { color: #f67400; } 
code span.bu { color: #d65d0e; } 
code span.cf { color: #cc241d; font-weight: bold; } 
code span.ch { color: #b16286; } 
code span.cn { color: #b16286; font-weight: bold; } 
code span.co { color: #928374; } 
code span.cv { color: #928374; } 
code span.do { color: #98971a; } 
code span.dt { color: #d79921; } 
code span.dv { color: #f67400; } 
code span.er { color: #cc241d; text-decoration: underline; } 
code span.ex { color: #689d6a; font-weight: bold; } 
code span.fl { color: #f67400; } 
code span.fu { color: #689d6a; } 
code span.im { color: #689d6a; } 
code span.in { color: #282828; background-color: #83a598; } 
code span.kw { color: #ebdbb2; font-weight: bold; } 
code span.op { color: #ebdbb2; } 
code span.ot { color: #689d6a; } 
code span.pp { color: #d65d0e; } 
code span.re { color: #928374; background-color: #1d2021; } 
code span.sc { color: #b16286; } 
code span.ss { color: #98971a; } 
code span.st { color: #98971a; } 
code span.va { color: #458588; } 
code span.vs { color: #848216; } 
code span.wa { color: #282828; background-color: #fabd2f; } 
</style>
  <style type="text/css">@import url('https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter&display=swap')</style>
  <style type="text/css">:root {
--bg: #282828;
--bg0-h: #1d2021;
--bg0-s: #32302f;
--bg0: #282828;
--bg1: #3c3836;
--bg2: #504945;
--bg3: #665c54;
--bg4: #7c6f64;
--fg: #ebdbb2;
--fg0: #fbf1c7;
--fg1: #ebdbb2;
--fg2: #d5c4a1;
--fg3: #bdae93;
--fg4: #a89984;
--dark-red: #cc241d;
--dark-green: #98971a;
--dark-yellow: #d79921;
--dark-orange: #d65d0e;
--dark-blue: #458588;
--dark-purple: #b16286;
--dark-aqua: #689d6a;
--dark-grey: #a89984;
--light-red: #fb4934;
--light-green: #b8bb26;
--light-yellow: #fabd2f;
--light-orange: #fe8019;
--light-blue: #83a598;
--light-purple: #d3869b;
--light-aqua: #8ec07c;
--light-grey: #928374;
--top-bar-bg-color: var(--fg0);
--top-bar-fg-color: var(--bg0-h);
--nav-bar-link-color: var(--fg0);
--nav-bar-link-hover-color: var(--light-orange);
--main-text-color: var(--fg);
--title-color: var(--light-aqua);
--section-color: var(--light-blue);
--link-color: var(--dark-blue);
--link-hover-color: var(--light-blue);
--inline-code-color: var(--light-orange);
--inline-code-bg-color: var(--bg1);
--code-bg-color: var(--bg1);
--content-width: 800px;
--keywords-color: var(--fg4);
--article-list-bg-color: var(--bg1);
--article-list-fg-color: var(--light-aqua);
--author-color: var(--dark-aqua);
}
::-webkit-scrollbar-thumb {
border-radius: 10px;

background-color: #0f0f0f;
}
::-webkit-scrollbar {
width: 12px;
height: 12px;
background-color: #282828;
}
::-webkit-scrollbar-track {
-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
border-radius: 10px;
background-color: #282828;
}
body {
padding: 2em;
font-size: 1rem;
padding-top: 0;
background-color: #282828;
color: var(--main-text-color);
font-family: 'Fira Code', monospace;
font-variant-ligatures: normal;
display: flex;
flex-flow: column nowrap;
align-items: center;
}
header {
width: 100%;
display: flex;
flex-flow: column nowrap;
align-items: center;
}
a {
color: var(--link-color);
transition: color ease-in 100ms;
font-weight: 600;
}
a:hover {
color: var(--link-hover-color);
}
h1 {
color: var(--title-color);
}
h1.title {
margin-bottom: .3em;
}
h1::after {
content: '';
display: block;
width: 100%;
border-bottom: solid 3px;
}
h2 {
color: var(--section-color);
}
code {
padding: 1px 6px;
border-radius: 3px;
color: var(--inline-code-color);
background-color: var(--inline-code-bg-color);
font-family: 'Fira Code';
font-variant-ligatures: normal;
}
code:not(.sourceCode) {
font-size: .8em;
}
pre code {
padding: 0;
border-radius: 0;
color: var(--main-text-color);
background-color: transparent;
font-size: 1em;
font-weight: normal;
}
pre.sourceCode {
padding: 1em;
background-color: var(--code-bg-color);
border-radius: 5px;
overflow: auto;
font-size: .9em;
}
p {
text-align: justify;
}
.text-underline {
text-decoration: underline;
}
.text-ligatures {
font-variant-ligatures: normal;
}
.text-hide {
display: none;
}
.list-title {
margin-bottom: 0;
}
.list-title ~ ul {
margin-top: 0;
}
.width-content {
width: var(--content-width);
}
.no-bottom-margin {
margin-bottom: 0;
}
#top-bar {
width: 100%;
padding: .5em;
background-color: var(--top-bar-bg-color);
color: var(--top-bar-fg-color);
display: flex;
flex-flow: row nowrap;
justify-content: center;
}
.blog-title {
text-transform: uppercase;
font-weight: bold;
}
#menu ul {
padding: 0;
display: flex;
flex-flow: row nowrap;
justify-content: flex-start;
gap: 2rem;
}
#menu ul li {
list-style: none;
}
#menu ul li a {
color: var(--nav-bar-link-color);
transition: color ease-in 100ms;
}
#menu ul li a:hover {
color: var(--nav-bar-link-hover-color);
}
.keywords > ul {
margin-top: 0;
display: flex;
flex-flow: row nowrap;
gap: 1em;
padding: 0;
color: var(--keywords-color);
}
.keywords > ul > li {
list-style: none;
}
.article-list > ul {
display: flex;
flex-flow: column nowrap;
gap: 1em;
padding: 0;
}
.article-list > ul > li {
padding: 0 1em;
background-color: var(--article-list-bg-color);
list-style: none;
}
.article-list > ul > li a {
font-variant-ligatures: normal;
color: var(--article-list-fg-color);
}
.article-title {
color: var(--title-color);
}
.article-title::after {
content: '';
display: block;
width: 100%;
border-bottom: solid 3px;
}
.author {
color: var(--author-color);
margin-top: .3em;
}
@media screen and (max-width: 1000px) {
.width-content {
width: calc(100% - 1rem);
}
body {
padding: 0;
font-size: .8rem;
}
}
</style>
</head>
    <body>
        <header>
            <div id="top-bar">
                <div class="width-content">
                    <div class="blog-title">Gabriel Dertoni</div>
                </div>
            </div>
            <nav class="width-content" id="menu">
                <ul>
                    <li><a href="/index.html">Index</a></li>
                    <li><a href="/about.html">About</a></li>
                </ul>
            </nav>
        </header>        <main class="width-content">
            <div id="title-block-header">
                <h1 class="title">Como nunca sofrer de segfault e double free</h1>
                <div class="keywords">
                    <ul>
                                            </ul>
                </div>
                <div class="authors">
                    <!-- Puts "Escrito por" when `lang-pt` is set and "Authored by" when `lang-en` is set -->
                    <p class="author"> Gabriel Dertoni</p>
                </div>
            </div>
            <nav id="TOC">
                <!-- Puts "Conteúdo" when `lang-pt` is set and "Contents" when `lang-en` is set -->
                <p class="list-title text-underline">Conteúdo:</p>
                <ul>
                <li><a href="#introdução" id="toc-introdução">Introdução</a></li>
                <li><a href="#quem-aloca-libera" id="toc-quem-aloca-libera">Quem aloca, libera</a></li>
                <li><a href="#donos-da-memória" id="toc-donos-da-memória">Donos da memória</a>
                <ul>
                <li><a href="#estruturas-sempre-alocadas-na-heap" id="toc-estruturas-sempre-alocadas-na-heap">Estruturas sempre alocadas na heap</a></li>
                <li><a href="#trabalhando-com-estruturas" id="toc-trabalhando-com-estruturas">Trabalhando com estruturas</a></li>
                <li><a href="#comentários-eficientes" id="toc-comentários-eficientes">Comentários eficientes</a></li>
                </ul></li>
                </ul>
            </nav>
            <h2 id="introdução">Introdução</h2>
            <p>Nesse post, pretendo definir dois conceitos que podem ajudar na hora de usar alocação dinâmica em linguagens sem gerenciamento de memória automático. O primeiro conceito será mais simples, mas também limitado, já o segundo será um pouco mais complexo, mas funciona de maneira mais genérica e pode ser aplicado a uma variedade maior de casos.</p>
            <h2 id="quem-aloca-libera">Quem aloca, libera</h2>
            <p>Muitas vezes ao escrever uma função ou um bloco de código, uma alocação dinâmica é necessária, mas apenas localmente. Nesses casos, podemos os usar a ideia de “quem aloca libera”. Logo após escrever o código de alocação, adicionamos o código de liberação logo em seguida, para garantir que não será esquecido.</p>
            <div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minha_funcao<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>ponteiro <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span><span class="dv">10</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>ponteiro<span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>O resto do código pode ser inserido entre o <code>malloc</code>e o <code>free</code>. Nesse modelo, não precisamos nos preocupar com nada além disso: escrever <code>malloc</code> seguido de <code>free</code> e depois vem o resto. Além disso, devemos imaginar que a variável <code>ponteiro</code> será a variável a ser liberada e por isso, não deve ser incrementada ou coisas do gênero. Além disso, só iremos fornecer esse ponteiro a outras funções se soubermos que essas outras funções <strong>não liberarão a memória dele</strong>, apenas o <code>free</code> ao fim do bloco deve fazer isso.</p>
            <h2 id="donos-da-memória">Donos da memória</h2>
            <p>Apesar da abordagem “quem aloca, libera” ter sua maior vantagem na simplicidade, nem sempre ela é suficiente. Por exemplo, digamos que exista uma função <code>readline</code> que lê uma linha da entrada padrão e retorna um ponteiro à string com os caracteres dessa linha. Nesse caso, a função <code>readline</code> é quem aloca a memória, mas ela precisa retornar essa memória ainda alocada e, por isso, não pode a liberar (como <a href="https://www.notion.so/Fun-es-puras-e-impuras-boas-pr-ticas-de-programa-o-5cc1e69008d3472c8badf9f291608458">comentado num outro artigo</a>, essas comportamentos devem ser documentadas).</p>
            <p>Nesse texto, usarei posse e propriedade de forma intercambiável. Existe uma diferença no sentido legal da palavra, mas para os propósitos desse texto, elas se referirão ao mesmo conceito.</p>
            <p>Para resolver esse problema, podemos usar o conceito de “dono ou proprietário da memória”. Um proprietário de memória é um ponteiro que aponta para um bloco qualquer de memória armazenada na heap com a importante responsabilidade de ser liberado. Esse ponteiro possui a posse de um bloco de memória e apenas ele deve liberá-lo. Para evitar <code>double free</code> devemos garantir que exista apenas um proprietário para cada alocação. No caso da função <code>readline</code>, diríamos que ela retorna a posse de um ponteiro. A função que chamadora recebe essa posse numa variável e então essa variável se torna a responsável por ser liberada. Por exemplo</p>
            <div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Retorna um ponteiro a uma alocação na heap que deve ser liberada através de `free`.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>readline<span class="op">()</span> <span class="op">{</span> <span class="co">/* implementação */</span> <span class="op">}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Input recebe a posse da memória alocada pela `readline`.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>input <span class="op">=</span> readline<span class="op">();</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outro ponteiro ao bloco de memória, entretanto, não</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// consideramos ele como proprietário, apenas uma referência.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>ptr <span class="op">=</span> <span class="op">&amp;</span>input<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Resto do código */</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>intput<span class="op">);</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Pode parecer óbvio, mas para que isso realmente funcione, algumas regras devem ser seguidas.</p>
            <ol type="1">
            <li>A posse do ponteiro não pode ser multiplicada, deve haver a cada momento apenas <strong>um</strong> proprietário.</li>
            <li>Quando um ponteiro proprietário chega ao final de seu uso, ele deve ceder a sua posse. A última instância disso é a função <code>free</code>, que toma como argumento a posse de um ponteiro e o libera, fazendo a posse “sumir”.</li>
            <li>Quando um ponteiro cede a posse de um bloco de memória, ele não pode mais ser liberado. Ele deixa de ser proprietário e se torna apenas uma referência ao bloco de memória. Entretanto, para manter as coisas mais seguras, podemos dizer que após ceder a posse, não devemos nunca mais usar esse ponteiro.</li>
            </ol>
            <h3 id="estruturas-sempre-alocadas-na-heap">Estruturas sempre alocadas na heap</h3>
            <p>Em alguns casos, é necessário escrever uma função de criação e liberação para alguma estrutura de dados customizada. Quando esse é o caso, haverá alguma função <code>liberar_estrutura()</code> que internamente libera todos os blocos necessários. Nesse caso, podemos dizer que a função de liberação toma propriedade do ponteiro. Por isso, após chamá-la, o ponteiro não pode mais ser liberado, já que não é mais proprietário. Um exemplo</p>
            <div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Um nó de uma lista encadeada.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> No <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> valor<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> No <span class="op">*</span>prox<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Função aloca um nó na heap e retorna um ponteiro a ele que deve ser liberado</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">// através da função `no_liberar`.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> No <span class="op">*</span>no_criar<span class="op">(</span><span class="dt">int</span> valor<span class="op">);</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Aponta o `prox` do primeiro nó para o segundo nó. Toma uma referência ao</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">// primeiro nó e a propriedade do segundo. Já que, ao ligar os dois nós e ao</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">// liberar o primeiro nó com `no_liberar`, liberaremos ambos.</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> no_link<span class="op">(</span><span class="kw">struct</span> No <span class="op">*</span>aponta<span class="op">,</span> <span class="kw">struct</span> No <span class="op">*</span>prox<span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Libera um nó e todos os nós encadeados a ele.</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> no_liberar<span class="op">(</span><span class="kw">struct</span> No <span class="op">*</span>no<span class="op">);</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Adquire propriedade do ponteiro.</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> No <span class="op">*</span>ponta <span class="op">=</span> no_criar<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Podemos até criar um escopo (opcional) para delimitar onde podemos usar</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a variável `proximo`, já que sabemos que ela irá ceder sua propriedade</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// e não deve mais ser usada depois. Isso faz o compilador trabalhar ao</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// nosso favor mas pode tornar o código excessivamente aninhado em alguns</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// cenários.</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Aqui `proximo` possui a propriedade de um bloco de memória.</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> No <span class="op">*</span>proximo <span class="op">=</span> no_criar<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// `proximo` perde a propriedade de seu bloco de memória, como descrito no</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// comentário da função.</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        no_link<span class="op">(</span>ponta<span class="op">,</span> proximo<span class="op">);</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* resto do código */</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// cede a propriedade do ponteiro. Aqui liberaremos ambos os blocos alocados</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// na heap.</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    no_liberar<span class="op">(</span>ponta<span class="op">);</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// `ponta-&gt;valor` não pode mais ser acessado.</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <h3 id="trabalhando-com-estruturas">Trabalhando com estruturas</h3>
            <p>Uma outra situação possível é quando criamos estruturas que em si são alocadas na <em>stack</em>, mas contém ponteiros para dados na <em>heap</em>.</p>
            <div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cap<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Cria um vetor que contém dados na heap e deve ser liberado através da</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// função `vec_free`.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec vec_new<span class="op">();</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vec_push<span class="op">(</span><span class="kw">struct</span> Vec <span class="op">*</span>v<span class="op">,</span> <span class="dt">int</span> val<span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vec_len<span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> Vec <span class="op">*</span>v<span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vec_free<span class="op">(</span>Vec v<span class="op">);</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A variável `inteiros` tem a propriedade de um vetor.</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Vec inteiros <span class="op">=</span> vec_new<span class="op">();</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cedemos referências a esse bloco de memória, elas não podem liberar</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a memória na heap pela convenção.</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    vec_push<span class="op">(&amp;</span>inteiros<span class="op">,</span> <span class="dv">80</span><span class="op">);</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    vec_push<span class="op">(&amp;</span>inteiros<span class="op">,</span> <span class="dv">42</span><span class="op">);</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    vec_free<span class="op">(</span>inteiros<span class="op">);</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Não podemos mais usar a variável `inteiros`.</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Aqui podemos diferenciar o que é proprietário e do que é referência. Podemos definir que, o variáveis do tipo <code>struct Vec</code> serão proprietárias, e <code>struct Vec *</code> será uma referência. Assim fica fácil! A função <code>vec_new()</code> claramente retorna <code>struct Vec</code> o que é uma propriedade. Além disso <code>vec_free</code> recebe uma propriedade, ou seja, alguma variável precisa ceder sua propriedade para poder chamar essa função.</p>
            <p>Isso torna intuitivo o conceito de posse e referência, quando vemos um ponteiro sabemos se tratar de uma referência que pode modificar a estrutura. Um ponteiro <code>const</code> é uma referência imutável e um tipo que não é um ponteiro representa uma posse.</p>
            <h3 id="comentários-eficientes">Comentários eficientes</h3>
            <p>Uma possibilidade de notação que desenvolvi é inspirado pela linguagem <a href="https://www.rust-lang.org/pt-BR">Rust</a>. Ao comentar os argumentos que uma função recebe, quando for um ponteiro, podemos denotar de uma forma dentre algumas possibilidades:</p>
            <ul>
            <li><p><code>[ref]</code> para referências que não modificam o conteúdo, um ponteiro constante.</p></li>
            <li><p><code>[ref mut]</code> para referências que modificam o conteúdo.</p></li>
            <li><p><code>[ownership]</code> para um parâmetro que transfere posse.</p></li>
            </ul>
            <p>Com essa notação podemos reescrever os comentários de um dos exemplos anteriores</p>
            <div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Um nó de uma lista encadeada.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> No <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> valor<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> No <span class="op">*</span>prox<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * Cria um nó alocado na heap com o valor especificado.</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * Parâmetros:</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co"> *   valor - o valor que o nó conterá.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * retorna - um nó alocado na heap. [ownership]</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> No <span class="op">*</span>no_criar<span class="op">(</span><span class="dt">int</span> valor<span class="op">);</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co"> * Conecta dois nós fazendo com que o `prox` do primeiro aponte para o segundo.</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co"> * Parâmetros:</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co"> *   aponta - o nó que terá o `prox` alterado. [ref mut]</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co"> *   prox - o nó para o qual `aponta-&gt;prox` apontará. [ownership]</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> no_link<span class="op">(</span><span class="kw">struct</span> No <span class="op">*</span>aponta<span class="op">,</span> <span class="kw">struct</span> No <span class="op">*</span>prox<span class="op">);</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * Libera um nó e todos os seus consecutivos.</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * Parâmetros:</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="co"> *   no - o nó a ser liberado. [ownership]</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> no_liberar<span class="op">(</span><span class="kw">struct</span> No <span class="op">*</span>no<span class="op">);</span></span></code></pre></div>
            <p>Claro, isso é apenas uma possibilidade de como documentar as funções e seus argumentos, e uma bem verbosa em particular. Mas serve bem o papel de informar a quaisquer usuários do código (inclusive e principalmente a mim mesmo) quais as propriedades esperadas dos argumentos e valores de retorno.</p>
        </main>
    </body>
</html>
